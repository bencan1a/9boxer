#!/usr/bin/env node
/**
 * Detect documentation impact from code changes
 *
 * This script analyzes git diff to detect component changes that affect documentation.
 * It maps changed files to screenshots using the component-screenshot-map.json
 * generated by extract-screenshot-metadata.js.
 *
 * Usage:
 *   node .github/scripts/detect-doc-impact.js [--base=main]
 *
 * Options:
 *   --base=BRANCH  Base branch to compare against (default: main)
 *
 * Outputs:
 *   - Sets GitHub Actions outputs: screenshots_affected, changed_components, affected_screenshots
 *   - Writes .affected-screenshots.json for screenshot regeneration
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '../..');

/**
 * Get changed files from git diff
 *
 * @param {string} baseBranch - Base branch to compare against
 * @returns {string[]} Array of changed file paths
 */
function getChangedFiles(baseBranch) {
  try {
    const output = execSync(`git diff --name-only origin/${baseBranch}...HEAD`, {
      cwd: PROJECT_ROOT,
      encoding: 'utf-8',
    });

    return output
      .split('\n')
      .map((line) => line.trim())
      .filter(Boolean);
  } catch (error) {
    console.error('‚ùå Failed to get changed files:', error.message);
    // Fallback: try without origin/ prefix
    try {
      const output = execSync(`git diff --name-only ${baseBranch}...HEAD`, {
        cwd: PROJECT_ROOT,
        encoding: 'utf-8',
      });

      return output
        .split('\n')
        .map((line) => line.trim())
        .filter(Boolean);
    } catch (fallbackError) {
      console.error('‚ùå Fallback also failed:', fallbackError.message);
      return [];
    }
  }
}

/**
 * Load component-screenshot mapping
 *
 * @returns {Object} Mapping data
 */
function loadComponentScreenshotMap() {
  const mapPath = path.join(PROJECT_ROOT, '.github/component-screenshot-map.json');

  if (!fs.existsSync(mapPath)) {
    console.error('‚ùå component-screenshot-map.json not found!');
    console.error('   Run: node .github/scripts/extract-screenshot-metadata.js');
    process.exit(1);
  }

  try {
    const content = fs.readFileSync(mapPath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    console.error('‚ùå Failed to load component-screenshot-map.json:', error.message);
    process.exit(1);
  }
}

/**
 * Map changed files to affected screenshots
 *
 * @param {string[]} changedFiles - Array of changed file paths
 * @param {Object} mapping - Component-screenshot mapping
 * @returns {Object} Analysis results
 */
function analyzeDocumentationImpact(changedFiles, mapping) {
  const affectedScreenshots = new Set();
  const changedComponents = [];
  const componentDetails = [];

  // Filter to frontend component files only
  const frontendFiles = changedFiles.filter((file) =>
    file.startsWith('frontend/src/')
  );

  console.log(`\nüìÅ Changed frontend files: ${frontendFiles.length}`);

  for (const file of frontendFiles) {
    // Convert absolute path to relative path from frontend/src/
    const relativePath = file.replace('frontend/src/', '');

    console.log(`\nüîç Checking: ${relativePath}`);

    // Check if this file is in our component mapping
    if (mapping.componentToScreenshots[relativePath]) {
      const componentData = mapping.componentToScreenshots[relativePath];
      const screenshots = componentData.screenshots;

      console.log(`   ‚úÖ Found in mapping: ${componentData.component}`);
      console.log(`   üì∏ Affects ${screenshots.length} screenshot(s): ${screenshots.join(', ')}`);

      changedComponents.push(relativePath);
      componentDetails.push({
        path: relativePath,
        component: componentData.component,
        screenshots: screenshots,
      });

      screenshots.forEach((s) => affectedScreenshots.add(s));
    } else {
      console.log(`   ‚è≠Ô∏è  Not in component mapping (no screenshots)`);
    }

    // Also check if any other components depend on this file
    // (e.g., shared utilities, hooks, contexts)
    const dependentComponents = findDependentComponents(relativePath, mapping);
    if (dependentComponents.length > 0) {
      console.log(`   üîó Affects ${dependentComponents.length} dependent component(s)`);
      dependentComponents.forEach((dep) => {
        const depData = mapping.componentToScreenshots[dep];
        if (depData) {
          console.log(`      - ${depData.component}: ${depData.screenshots.join(', ')}`);
          depData.screenshots.forEach((s) => affectedScreenshots.add(s));

          if (!changedComponents.includes(dep)) {
            changedComponents.push(dep);
            componentDetails.push({
              path: dep,
              component: depData.component,
              screenshots: depData.screenshots,
              indirect: true,
            });
          }
        }
      });
    }
  }

  // Also check for theme changes that affect all components
  const themeChanged = changedFiles.some((file) => file.includes('frontend/src/theme/'));
  if (themeChanged) {
    console.log('\nüé® Theme files changed - potentially affects all screenshots');
  }

  return {
    changedFiles: frontendFiles,
    changedComponents,
    componentDetails,
    affectedScreenshots: Array.from(affectedScreenshots).sort(),
    themeChanged,
  };
}

/**
 * Find components that depend on a given file
 *
 * LIMITATION: Simple heuristic based on directory proximity.
 * Only detects dependencies in the same directory or subdirectories.
 * Does NOT parse actual import statements, so cross-directory
 * dependencies may be missed.
 *
 * Example: If `components/grid/NineBoxGrid.tsx` imports `hooks/useEmployee.ts`
 * from a different directory, this function will NOT detect that dependency.
 *
 * TODO: Phase 3 enhancement - parse import statements for accurate detection
 *
 * @param {string} filePath - File path
 * @param {Object} mapping - Component-screenshot mapping
 * @returns {string[]} Array of dependent component paths
 */
function findDependentComponents(filePath, mapping) {
  const dependents = [];
  const dir = path.dirname(filePath);

  // If it's a utility/hook/context file, check components in same directory
  if (
    filePath.includes('/hooks/') ||
    filePath.includes('/utils/') ||
    filePath.includes('/contexts/') ||
    filePath.includes('/services/')
  ) {
    for (const componentPath of Object.keys(mapping.componentToScreenshots)) {
      if (componentPath.startsWith(dir) && componentPath !== filePath) {
        dependents.push(componentPath);
      }
    }
  }

  return dependents;
}

/**
 * Set GitHub Actions outputs
 *
 * @param {Object} results - Analysis results
 */
function setGitHubOutputs(results) {
  const outputFile = process.env.GITHUB_OUTPUT;

  if (!outputFile) {
    console.log('\n‚ö†Ô∏è  GITHUB_OUTPUT not set - skipping GitHub Actions outputs');
    return;
  }

  try {
    const outputs = [
      `screenshots_affected=${results.affectedScreenshots.length > 0}`,
      `changed_components=${results.changedComponents.join(', ')}`,
      `affected_screenshots=${results.affectedScreenshots.join(', ')}`,
      `screenshot_count=${results.affectedScreenshots.length}`,
      `component_count=${results.changedComponents.length}`,
      `theme_changed=${results.themeChanged}`,
    ];

    fs.appendFileSync(outputFile, outputs.join('\n') + '\n');
    console.log('\n‚úÖ GitHub Actions outputs set');
  } catch (error) {
    console.error('‚ùå Failed to set GitHub Actions outputs:', error.message);
  }
}

/**
 * Save affected screenshots to file
 *
 * @param {Object} results - Analysis results
 */
function saveAffectedScreenshots(results) {
  const outputPath = path.join(PROJECT_ROOT, '.affected-screenshots.json');

  const data = {
    screenshots: results.affectedScreenshots,
    components: results.componentDetails,
    metadata: {
      generatedAt: new Date().toISOString(),
      generatedBy: 'detect-doc-impact.js',
      totalScreenshots: results.affectedScreenshots.length,
      totalComponents: results.changedComponents.length,
      themeChanged: results.themeChanged,
    },
  };

  try {
    fs.writeFileSync(outputPath, JSON.stringify(data, null, 2));
    console.log(`\nüíæ Saved affected screenshots to: ${path.relative(PROJECT_ROOT, outputPath)}`);
  } catch (error) {
    console.error('‚ùå Failed to save affected screenshots:', error.message);
    process.exit(1);
  }
}

/**
 * Generate summary report
 *
 * @param {Object} results - Analysis results
 */
function printSummary(results) {
  console.log('\n' + '‚îÄ'.repeat(60));
  console.log('üìä Documentation Impact Analysis Summary');
  console.log('‚îÄ'.repeat(60));

  console.log(`\nüìÅ Changed Files: ${results.changedFiles.length}`);
  console.log(`üß© Changed Components: ${results.changedComponents.length}`);
  console.log(`üì∏ Affected Screenshots: ${results.affectedScreenshots.length}`);

  if (results.themeChanged) {
    console.log(`üé® Theme Changed: YES (may require broader screenshot review)`);
  }

  if (results.changedComponents.length > 0) {
    console.log('\nüìã Component Details:');
    results.componentDetails.forEach((comp) => {
      const badge = comp.indirect ? 'üîó' : '‚úÖ';
      console.log(`\n   ${badge} ${comp.component} (${comp.path})`);
      console.log(`      Screenshots: ${comp.screenshots.join(', ')}`);
      if (comp.indirect) {
        console.log(`      (Indirectly affected)`);
      }
    });
  }

  if (results.affectedScreenshots.length > 0) {
    console.log('\nüì∏ Screenshots to Regenerate:');
    results.affectedScreenshots.forEach((screenshot, index) => {
      console.log(`   ${index + 1}. ${screenshot}`);
    });
  } else {
    console.log('\n‚úÖ No screenshots affected by these changes');
  }

  console.log('\n' + '‚îÄ'.repeat(60));
}

/**
 * Main function
 */
function main() {
  console.log('üîç Analyzing documentation impact from code changes...\n');

  // Parse command line arguments
  const args = process.argv.slice(2);
  const baseArg = args.find((arg) => arg.startsWith('--base='));
  const baseBranch = baseArg ? baseArg.split('=')[1] : process.env.GITHUB_BASE_REF || 'main';

  // Validate baseBranch
  if (!baseBranch || baseBranch.trim() === '') {
    console.error('‚ùå Invalid base branch (empty)');
    process.exit(1);
  }
  if (!/^[a-zA-Z0-9/_-]+$/.test(baseBranch)) {
    console.error('‚ùå Invalid base branch name (contains invalid characters)');
    process.exit(1);
  }

  console.log(`üìå Base branch: ${baseBranch}`);

  // Load component-screenshot mapping
  const mapping = loadComponentScreenshotMap();
  console.log(`üì¶ Loaded mapping with ${mapping.metadata.totalComponents} components`);

  // Get changed files
  const changedFiles = getChangedFiles(baseBranch);
  console.log(`üìù Total changed files: ${changedFiles.length}`);

  if (changedFiles.length === 0) {
    console.log('\n‚úÖ No files changed');
    process.exit(0);
  }

  // Analyze documentation impact
  const results = analyzeDocumentationImpact(changedFiles, mapping);

  // Save results
  saveAffectedScreenshots(results);

  // Set GitHub Actions outputs
  setGitHubOutputs(results);

  // Print summary
  printSummary(results);

  // Exit with appropriate code
  if (results.affectedScreenshots.length > 0) {
    console.log('\n‚ö†Ô∏è  Documentation updates required!');
    process.exit(0); // Success, but with screenshots to regenerate
  } else {
    console.log('\n‚úÖ No documentation impact detected');
    process.exit(0);
  }
}

// Only run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

// Export functions for testing
export {
  getChangedFiles,
  loadComponentScreenshotMap,
  analyzeDocumentationImpact,
  findDependentComponents,
};
